<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>开机动画</title>
  <style>
    /* 全屏黑底与科技网格 */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width:100%; height:100%; overflow:hidden; background:#000; }
    #boot-screen {
      position: relative;
      width:100%; height:100%;
      background:
        repeating-linear-gradient(0deg, transparent, transparent 25px, rgba(0,255,255,0.04) 26px),
        repeating-linear-gradient(90deg, transparent, transparent 25px, rgba(0,255,255,0.04) 26px),
        #000;
    }
    /* 扫描光束 */
    #boot-screen::after {
      content: '';
      position: absolute;
      top: -100%; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(to bottom, transparent 0%, rgba(0,255,255,0.2) 50%, transparent 100%);
      animation: scan 3s linear infinite;
      pointer-events: none;
      z-index: 2;
    }
    @keyframes scan {
      0%   { top: -100%; }
      100% { top: 100%; }
    }
    /* 画布层 */
    canvas#network {
      position: absolute;
      top:0; left:0;
      width:100%; height:100%;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="boot-screen">
    <canvas id="network"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('network');
    const ctx = canvas.getContext('2d');
    let W, H;
    const points = [];
    const POINT_COUNT = 80;
    const MAX_DIST = 120;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 初始化点
    for (let i = 0; i < POINT_COUNT; i++) {
      points.push({
        x: Math.random() * W,
        y: Math.random() * H,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3
      });
    }

    function animate() {
      ctx.clearRect(0, 0, W, H);

      // 更新位置
      points.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0 || p.x > W) p.vx *= -1;
        if (p.y < 0 || p.y > H) p.vy *= -1;
      });

      // 画线与点
      for (let i = 0; i < POINT_COUNT; i++) {
        const p1 = points[i];
        // 点
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,255,255,0.7)';
        ctx.fill();

        // 连线
        for (let j = i + 1; j < POINT_COUNT; j++) {
          const p2 = points[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.hypot(dx, dy);
          if (dist < MAX_DIST) {
            const alpha = 1 - dist / MAX_DIST;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = `rgba(0,255,255,${alpha * 0.5})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      }

      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>